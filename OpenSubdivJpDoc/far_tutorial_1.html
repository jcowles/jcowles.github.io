<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>far_tutorial_1.cpp</title>
<link rel="icon" type="image/png" href="images/icon.png">
<link rel="stylesheet" href="css/rst.css" type="text/css" />
<link rel="stylesheet" href="css/default.css" type="text/css" />
<link rel="stylesheet" href="css/flavor.css" type="text/css" />
<link rel="stylesheet" href="css/renderman-university.css" type="text/css" />
<link rel="stylesheet" href="css/pygments.css" type="text/css" />
<style>
#mainContentContainer {
    left: 15px;
    margin-left: 255px;
}
ul.creatorFooterNav {
    margin-left: 100px;
}
.navigation {
    background-color: #333333;
    margin-top: 10px;
    margin-left: 10px;
}
ul.creatorMainNav li a {
    font-size: 12px !important;
}
</style>
</head>
<body>

<div class="navigation">
    <br>
    <div class="searchBar">
        <form action="search.html">
            <input type="text" name="q" id="searchInput" />
            <input type="button" id="searchButton" onclick="this.form.submit();" value="Search" />
        </form>
    </div>
    <div class="quickLinks">
        <ul>
            <li><a href="intro.html">はじめに</a></li>
                <ul>
                    <li><a href="license.html">ライセンス (en)</a></li>
                    <li><a href="getting_started.html">始めよう (en)</a></li>
                    <li><a href="contributing.html">参加しよう (en)</a></li>
                    <li><a href="cmake_build.html">ビルド方法 (en)</a></li>
                    <li><a href="code_examples.html">コード例 (en)</a></li>
                    <li><a href="roadmap.html">ロードマップ (en)</a></li>
                </ul>
            <p></p>
            <li><a href="intro_30.html">リリース 3.0</a></li>
                <ul>
                    <li><a href="intro_30.html">概要</a></li>
                    <li><a href="porting.html">2.0から3.0への移植ガイド (en)</a></li>
                    <li><a href="compatibility.html">サブディビジョンの互換性 (en)</a></li>
                </ul>
            <p></p>
            <li><a href="subdivision_surfaces.html">サブディビジョンサーフェス</a>
                <ul>
                    <li><a href="subdivision_surfaces.html#introduction">はじめに</a></li>
                    <li><a href="subdivision_surfaces.html#arbitrary-topology">トポロジ</a></li>
                    <li><a href="subdivision_surfaces.html#uniform-subdivision">均一分割</a></li>
                    <li><a href="subdivision_surfaces.html#feature-adaptive-subdivision">適応分割</a></li>
                    <li><a href="subdivision_surfaces.html#boundary-interpolation-rules">境界補間則</a></li>
                    <li><a href="subdivision_surfaces.html#face-varying-interpolation-rules">面変化境界補間則</a></li>
                    <li><a href="subdivision_surfaces.html#semi-sharp-creases">セミシャープクリース</a></li>
                    <li><a href="mod_notes.html">モデリングのコツ (en)</a></li>
                </ul>
            </li>
            <p></p>
            <li><a href="api_overview.html">OpenSubdiv ユーザーガイド (en)</a>
                <ul>
                    <li><a href="api_overview.html">API概要 (en)</a>
                        <li><a href="sdc_overview.html">Sdc (en)</a></li>
                        <li><a href="vtr_overview.html">Vtr (en)</a></li>
                        <li><a href="far_overview.html">Far (en)</a></li>
                        <ul>
                            <li><a href="far_overview.html#far-topologyrefiner">Topology Refiner (en)</a></li>
                            <li><a href="far_overview.html#far-topologyrefinerfactory">Topology Refiner Factory (en)</a></li>
                            <li><a href="far_overview.html#far-primvarrefiner">Primvar Refiner (en)</a></li>
                            <li><a href="far_overview.html#far-patchtable">Patch Table (en)</a></li>
                            <li><a href="far_overview.html#far-stenciltable">Stencil Table v</a></li>
                        </ul>
                        <li><a href="osd_overview.html">Osd (en)</a></li>
                        <ul>
                            <li><a href="osd_shader_interface.html">シェーダインタフェース (en)</a></li>
                        </ul>
                    </li>
                    <p></p>
                    <li><a href="tutorials.html">チュートリアル (en)</a>
                    <p></p>
                    <li><a href="hbr_overview.html">過去の情報 (en)</a></li>
                    <ul>
                        <li><a href="hbr_overview.html">Hbr (en)</a></li>
                        <ul>
                            <li><a href="using_osd_hbr.html">Using Hbr (en)</a></li>
                        </ul>
                        <li><a href="hedits.html">階層エディット (en)</a></li>
                    </ul>
                </ul>
            </li>
            <p></p>
            <li><a href="additional_resources.html">追加情報 (en)</a>
                <ul>
                    <li><a href="http://graphics.pixar.com/opensubdiv/forum.html">フォーラム</a>
                    <li><a href="additional_resources.html#links">リンク</a>
                    <li><a href="additional_resources.html#videos">ビデオ</a>
                </ul>
            <p></p>
            <li><a href="release_notes.html">リリースノート</a>
            <p></p>
            <li><a href="doxy_html/index.html" target="_blank">Doxygen</a></li>
        </ul>
    </div>
    <br>
</div>

<div class="document" id="far-tutorial-1-cpp">
<h1 class="title">far_tutorial_1.cpp</h1>


    <div id="mainContentContainer">
        <div class="fullWidth headerColor">
            <div class="center">
                <div id="mainSiteNavigation">
                    <div class="homeRenderManLink">
                        <a href="http://graphics.pixar.com/opensubdiv/index.html"><img alt="OpenSubdiv Logo" src="images/opensubdiv_logo_header.png"></a>
                    </div>
          
					<!-- TOP NAVIGATION MENU -->
                    <ul class="creatorMainNav floatLeft" id="menu">
                        <li class="creatorMainNav">
                            <a href="release_notes.html">3.0.0</a>
                        </li>
                    </ul>
                    <ul class="creatorMainNav floatNav" id="menu">
                        <li class="mainSubNavigation marginR12 marginL12" id="navbarId-23704">
                            <a href="intro.html">User Docs</a>
                        </li>
                        <li class="mainSubNavigation marginR12 marginL12" id="navbarId-23887">
                            <a href="doxy_html/index.html">API Docs</a>
                        </li>
                        <li class="mainSubNavigation marginR12 marginL12" id="navbarId-23944">
                            <a href="release_notes.html">Release Notes</a>
                        </li>
                        <li class="mainSubNavigation marginR15 marginL12" id="navbarId-23703">
                            <a href="http://graphics.pixar.com/opensubdiv/forum.html">Forum</a>
                        </li>
                        <a class="blueButton marginR0 marginL0" style="width:70px" href="https://github.com/PixarAnimationStudios/OpenSubdiv">Github</a>
                    </ul>
                </div><!-- close mainSiteNavigation -->
            </div><!-- close center -->
        </div><!-- close fullWidth -->


        <div class="clearBoth"></div>
        
        <h1 class="articleContentTitle">far_tutorial_1.cpp</h1>
        
        <div class="clearBoth"></div>
        
        <hr>
        
        <div class="clearBoth"></div>
        
        <div class="coursewareBackground">

          <!-- <div class="topicLeftData-IntroPara"></div> -->
          <div class="topicLeftData-MainData">
<p><a class="reference external" href="https://github.com/PixarAnimationStudios/OpenSubdiv/blob/master/tutorials/far/tutorial_1/far_tutorial_1.cpp">https://github.com/PixarAnimationStudios/OpenSubdiv/blob/master/tutorials/far/tutorial_1/far_tutorial_1.cpp</a></p>
<hr class="docutils" />
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">/Users/tejima/dev/OpenSubdiv.jpdoc/build/documentation/far_tutorial_1.rst</tt>, line 9)</p>
<p>Cannot analyze code. Pygments package not found.</p>
<pre class="literal-block">
.. code:: c

    //------------------------------------------------------------------------------
    // Tutorial description:
    //
    // This tutorial shows how to interface a high-level topology representation
    // with Far for better efficiency. In tutorial 0, we showed how to instantiate
    // topology from a simple face-vertex list. Here we will show how to take
    // advantage of more complex data structures.
    //
    // Many client applications that manipulate geometry use advanced data structures
    // such as half-edge, quad-edge or winged-edge in order to represent complex
    // topological relationships beyond the usual face-vertex lists. We can take
    // advantage of this information.
    //
    // Far provides an advanced interface that allows such a client application to
    // communicate advanced component relationships directly and avoid having Far
    // rebuilding them redundantly.
    //

    #include &lt;opensubdiv/far/topologyRefinerFactory.h&gt;
    #include &lt;opensubdiv/far/primvarRefiner.h&gt;

    #include &lt;cstdio&gt;

    //------------------------------------------------------------------------------

    using namespace OpenSubdiv;

    //------------------------------------------------------------------------------
    //
    // For this tutorial, we provide the complete topological representation of a
    // simple pyramid. In our case, we store it as a simple sequence of integers,
    // with the understanding that client-code would provide a fully implemented
    // data-structure such as quad-edges or winged-edges.
    //
    // Pyramid geometry from catmark_pyramid.h - extended for this tutorial
    //
    static int g_nverts = 5,
               g_nedges = 8,
               g_nfaces = 5;

    // vertex positions
    static float g_verts[5][3] = {{ 0.0f,  0.0f,  2.0f},
                                  { 0.0f, -2.0f,  0.0f},
                                  { 2.0f,  0.0f,  0.0f},
                                  { 0.0f,  2.0f,  0.0f},
                                  {-2.0f,  0.0f,  0.0f}};

    // number of vertices in each face
    static int g_facenverts[5] = { 3, 3, 3, 3, 4 };

    // index of face vertices
    static int g_faceverts[16] = { 0, 1, 2,
                                   0, 2, 3,
                                   0, 3, 4,
                                   0, 4, 1,
                                   4, 3, 2, 1 };

    // index of edge vertices (2 per edge)
    static int g_edgeverts[16] = { 0, 1,
                                   1, 2,
                                   2, 0,
                                   2, 3,
                                   3, 0,
                                   3, 4,
                                   4, 0,
                                   4, 1 };


    // index of face edges
    static int g_faceedges[16] = { 0, 1, 2,
                                   2, 3, 4,
                                   4, 5, 6,
                                   6, 7, 0,
                                   5, 3, 1, 7 };

    // number of faces adjacent to each edge
    static int g_edgenfaces[8] = { 2, 2, 2, 2, 2, 2, 2, 2 };

    // index of faces incident to a given edge
    static int g_edgefaces[16] = { 0, 3,
                                   0, 4,
                                   0, 1,
                                   1, 4,
                                   1, 2,
                                   2, 4,
                                   2, 3,
                                   3, 4 };

    // number of faces incident to each vertex
    static int g_vertexnfaces[5] = { 4, 3, 3, 3, 3 };

    // index of faces incident to each vertex
    static int g_vertexfaces[25] = { 0, 1, 2, 3,
                                     0, 3, 4,
                                     0, 4, 1,
                                     1, 4, 2,
                                     2, 4, 3 };


    // number of edges incident to each vertex
    static int g_vertexnedges[5] = { 4, 3, 3, 3, 3 };

    // index of edges incident to each vertex
    static int g_vertexedges[25] = { 0, 2, 4, 6,
                                     1, 0, 7,
                                     2, 1, 3,
                                     4, 3, 5,
                                     6, 5, 7 };

    // Edge crease sharpness
    static float g_edgeCreases[8] = { 0.0f,
                                      2.5f,
                                      0.0f,
                                      2.5f,
                                      0.0f,
                                      2.5f,
                                      0.0f,
                                      2.5f };

    //------------------------------------------------------------------------------
    //
    // Because existing client-code may not provide an exact match for the
    // topological queries required by Far's interface, we can provide a converter
    // class. This can be particularly useful for instance if the client
    // data-structure requires additional relationships to be mapped. For instance,
    // half-edge representations do not store unique edge indices and it can be
    // difficult to traverse edges or faces adjacent to a given vertex.
    //
    // Using an intermediate wrapper class allows us to leverage existing
    // relationships information from a mesh, and generate the missing components
    // temporarily.
    //
    // For a practical example, you can look at the file 'hbr_to_vtr.h' in the same
    // tutorial directory. This example implements a 'OsdHbrConverter' class as a
    // way of interfacing PRman's half-edge representation to Far.
    //
    struct Converter {

    public:

        Sdc::SchemeType GetType() const {
            return Sdc::SCHEME_CATMARK;
        }

        Sdc::Options GetOptions() const {
            Sdc::Options options;
            options.SetVtxBoundaryInterpolation(Sdc::Options::VTX_BOUNDARY_EDGE_ONLY);
            return options;
        }

        int GetNumFaces() const { return g_nfaces; }

        int GetNumEdges() const { return g_nedges; }

        int GetNumVertices() const { return g_nverts; }

        //
        // Face relationships
        //
        int GetNumFaceVerts(int face) const { return g_facenverts[face]; }

        int const * GetFaceVerts(int face) const { return g_faceverts+getCompOffset(g_facenverts, face); }

        int const * GetFaceEdges(int edge) const { return g_faceedges+getCompOffset(g_facenverts, edge); }


        //
        // Edge relationships
        //
        int const * GetEdgeVertices(int edge) const { return g_edgeverts+edge*2; }

        int GetNumEdgeFaces(int edge) const { return g_edgenfaces[edge]; }

        int const * GetEdgeFaces(int edge) const { return g_edgefaces+getCompOffset(g_edgenfaces, edge); }

        //
        // Vertex relationships
        //
        int GetNumVertexEdges(int vert) const { return g_vertexnedges[vert]; }

        int const * GetVertexEdges(int vert) const { return g_vertexedges+getCompOffset(g_vertexnedges, vert); }

        int GetNumVertexFaces(int vert) const { return g_vertexnfaces[vert]; }

        int const * GetVertexFaces(int vert) const { return g_vertexfaces+getCompOffset(g_vertexnfaces, vert); }

    private:

        int getCompOffset(int const * comps, int comp) const {
            int ofs=0;
            for (int i=0; i&lt;comp; ++i) {
                ofs += comps[i];
            }
            return ofs;
        }

    };

    //------------------------------------------------------------------------------

    namespace OpenSubdiv {
    namespace OPENSUBDIV_VERSION {

    namespace Far {

    template &lt;&gt;
    bool
    TopologyRefinerFactory&lt;Converter&gt;::resizeComponentTopology(
        TopologyRefiner &amp; refiner, Converter const &amp; conv) {

        // Faces and face-verts
        int nfaces = conv.GetNumFaces();
        setNumBaseFaces(refiner, nfaces);
        for (int face=0; face&lt;nfaces; ++face) {

            int nv = conv.GetNumFaceVerts(face);
            setNumBaseFaceVertices(refiner, face, nv);
        }

       // Edges and edge-faces
        int nedges = conv.GetNumEdges();
        setNumBaseEdges(refiner, nedges);
        for (int edge=0; edge&lt;nedges; ++edge) {

            int nf = conv.GetNumEdgeFaces(edge);
            setNumBaseEdgeFaces(refiner, edge, nf);
        }

        // Vertices and vert-faces and vert-edges
        int nverts = conv.GetNumVertices();
        setNumBaseVertices(refiner, nverts);
        for (int vert=0; vert&lt;nverts; ++vert) {

            int ne = conv.GetNumVertexEdges(vert),
                nf = conv.GetNumVertexFaces(vert);
            setNumBaseVertexEdges(refiner, vert, ne);
            setNumBaseVertexFaces(refiner, vert, nf);
        }
        return true;
    }

    template &lt;&gt;
    bool
    TopologyRefinerFactory&lt;Converter&gt;::assignComponentTopology(
        TopologyRefiner &amp; refiner, Converter const &amp; conv) {

        typedef Far::IndexArray      IndexArray;

        { // Face relations:
            int nfaces = conv.GetNumFaces();
            for (int face=0; face&lt;nfaces; ++face) {

                IndexArray dstFaceVerts = getBaseFaceVertices(refiner, face);
                IndexArray dstFaceEdges = getBaseFaceEdges(refiner, face);

                int const * faceverts = conv.GetFaceVerts(face);
                int const * faceedges = conv.GetFaceEdges(face);

                for (int vert=0; vert&lt;conv.GetNumFaceVerts(face); ++vert) {
                    dstFaceVerts[vert] = faceverts[vert];
                    dstFaceEdges[vert] = faceedges[vert];
                }
            }
        }

        { // Edge relations
          //
          // Note: if your representation is unable to provide edge relationships
          //       (ex: half-edges), you can comment out this section and Far will
          //       automatically generate the missing information.
          //
            int nedges = conv.GetNumEdges();
            for (int edge=0; edge&lt;nedges; ++edge) {

                //  Edge-vertices:
                IndexArray dstEdgeVerts = getBaseEdgeVertices(refiner, edge);
                dstEdgeVerts[0] = conv.GetEdgeVertices(edge)[0];
                dstEdgeVerts[1] = conv.GetEdgeVertices(edge)[1];

                //  Edge-faces
                IndexArray dstEdgeFaces = getBaseEdgeFaces(refiner, edge);
                for (int face=0; face&lt;conv.GetNumEdgeFaces(face); ++face) {
                    dstEdgeFaces[face] = conv.GetEdgeFaces(edge)[face];
                }
            }
        }

        { // Vertex relations
            int nverts = conv.GetNumVertices();
            for (int vert=0; vert&lt;nverts; ++vert) {

                //  Vert-Faces:
                IndexArray vertFaces = getBaseVertexFaces(refiner, vert);
                //LocalIndexArray vertInFaceIndices = getBaseVertexFaceLocalIndices(refiner, vert);
                for (int face=0; face&lt;conv.GetNumVertexFaces(vert); ++face) {
                    vertFaces[face] = conv.GetVertexFaces(vert)[face];
                }

                //  Vert-Edges:
                IndexArray vertEdges = getBaseVertexEdges(refiner, vert);
                //LocalIndexArray vertInEdgeIndices = getBaseVertexEdgeLocalIndices(refiner, vert);
                for (int edge=0; edge&lt;conv.GetNumVertexEdges(vert); ++edge) {
                    vertEdges[edge] = conv.GetVertexEdges(vert)[edge];
                }
            }
        }

        populateBaseLocalIndices(refiner);

        return true;
    };

    template &lt;&gt;
    bool
    TopologyRefinerFactory&lt;Converter&gt;::assignComponentTags(
        TopologyRefiner &amp; refiner, Converter const &amp; conv) {

        // arbitrarily sharpen the 4 bottom edges of the pyramid to 2.5f
        for (int edge=0; edge&lt;conv.GetNumEdges(); ++edge) {
            setBaseEdgeSharpness(refiner, edge, g_edgeCreases[edge]);
        }
        return true;
    }

    #ifdef _MSC_VER
    template &lt;&gt;
    void
    TopologyRefinerFactory&lt;Converter&gt;::reportInvalidTopology(
        TopologyError /* errCode */, char const * msg, Converter const&amp; /* mesh */) {

        //
        //  Optional topology validation error reporting:
        //      This method is called whenever the factory encounters topology validation
        //  errors. By default, nothing is reported
        //
        Warning(msg);
    }
    template &lt;&gt;
    bool
    TopologyRefinerFactory&lt;Converter&gt;::assignFaceVaryingTopology(
        TopologyRefiner &amp; /* refiner */, Converter const &amp; /* conv */) {

        // Because of the way MSVC++ specializes templated functions, we had to
        // remove the default stubs in Far::TopologyRefinerFactory. In this
        // example, no face-varying data is being added, but we still need to
        // implement a template specialization or MSVC++ linker fails.
        return true;
    }
    #endif

    } // namespace Far

    } // namespace OPENSUBDIV_VERSION
    } // namespace OpenSubdiv

    //------------------------------------------------------------------------------
    //
    // Vertex container implementation.
    //
    struct Vertex {

        // Minimal required interface ----------------------
        Vertex() { }

        Vertex(Vertex const &amp; src) {
            _position[0] = src._position[0];
            _position[1] = src._position[1];
            _position[2] = src._position[2];
        }

        void Clear( void * =0 ) {
            _position[0]=_position[1]=_position[2]=0.0f;
        }

        void AddWithWeight(Vertex const &amp; src, float weight) {
            _position[0]+=weight*src._position[0];
            _position[1]+=weight*src._position[1];
            _position[2]+=weight*src._position[2];
        }

        void AddVaryingWithWeight(Vertex const &amp;, float) { }

        // Public interface ------------------------------------
        void SetPosition(float x, float y, float z) {
            _position[0]=x;
            _position[1]=y;
            _position[2]=z;
        }

        const float * GetPosition() const {
            return _position;
        }

    private:
        float _position[3];
    };

    //------------------------------------------------------------------------------
    int main(int, char **) {

        Converter conv;

        Far::TopologyRefiner * refiner =
            Far::TopologyRefinerFactory&lt;Converter&gt;::Create(conv,
                    Far::TopologyRefinerFactory&lt;Converter&gt;::Options(conv.GetType(), conv.GetOptions()));


        int maxlevel = 5;

        // Uniformly refine the topolgy up to 'maxlevel'
        refiner-&gt;RefineUniform(Far::TopologyRefiner::UniformOptions(maxlevel));


        // Allocate a buffer for vertex primvar data. The buffer length is set to
        // be the sum of all children vertices up to the highest level of refinement.
        std::vector&lt;Vertex&gt; vbuffer(refiner-&gt;GetNumVerticesTotal());
        Vertex * verts = &amp;vbuffer[0];


        // Initialize coarse mesh positions
        int nCoarseVerts = g_nverts;
        for (int i=0; i&lt;nCoarseVerts; ++i) {
            verts[i].SetPosition(g_verts[i][0], g_verts[i][1], g_verts[i][2]);
        }


        // Interpolate vertex primvar data
        Far::PrimvarRefiner primvarRefiner(*refiner);

        Vertex * src = verts;
        for (int level = 1; level &lt;= maxlevel; ++level) {
            Vertex * dst = src + refiner-&gt;GetLevel(level-1).GetNumVertices();
            primvarRefiner.Interpolate(level, src, dst);
            src = dst;
        }


        { // Output OBJ of the highest level refined -----------

            Far::TopologyLevel const &amp; refLastLevel = refiner-&gt;GetLevel(maxlevel);

            int nverts = refLastLevel.GetNumVertices();
            int nfaces = refLastLevel.GetNumFaces();

            // Print vertex positions
            int firstOfLastVerts = refiner-&gt;GetNumVerticesTotal() - nverts;

            for (int vert = 0; vert &lt; nverts; ++vert) {
                float const * pos = verts[firstOfLastVerts + vert].GetPosition();
                printf(&quot;v %f %f %f\n&quot;, pos[0], pos[1], pos[2]);
            }

            // Print faces
            for (int face = 0; face &lt; nfaces; ++face) {

                Far::ConstIndexArray fverts = refLastLevel.GetFaceVertices(face);

                // all refined Catmark faces should be quads
                assert(fverts.size()==4);

                printf(&quot;f &quot;);
                for (int vert=0; vert&lt;fverts.size(); ++vert) {
                    printf(&quot;%d &quot;, fverts[vert]+1); // OBJ uses 1-based arrays...
                }
                printf(&quot;\n&quot;);
            }
        }
    }

    //------------------------------------------------------------------------------

</pre>
</div>
</div>
<div class="footer">
<hr class="footer" />
Generated on: 2015-06-24 04:40 UTC.

</div>
</body>
</html>

          </div><!-- close topicLeftData-MainData -->
        </div><!-- close coursewareBackground -->
    </div> <!-- close mainContentContainer -->
</div> <!-- close center -->

<div class="clearBoth"></div>


<div class="center">

    <div class="copyrightFooter">
    </div>


<!-- BOTTOM NAVIGATION MENU -->
    <ul class="creatorFooterNav">
        <li class="" id="navbarId-23704">
            <a href="intro.html">User Docs</a>
        </li>
        <li class="" id="navbarId-23887">
            <a href="doxy_html/index.html">API Docs</a>
        </li>
        <li class="" id="navbarId-23944">
            <a href="release_notes.html">Release Notes</a>
        </li>
        <li class="" id="navbarId-23703">
            <a href="http://graphics.pixar.com/opensubdiv/forum.html">Forum</a>
        </li>
    </ul><!-- end bottom navigation menu -->

<div class="clearBoth"></div>
